---
layout: post
title:  "粒子滤波"
date:   2014-08-21 20:00:00
---
最近我使用C++和opencv实现了最基本的粒子滤波，总算掌握了其各个细节，鉴于网上的各种资料都是抄来抄去，很少有能讲清楚的，在这里写下我的理解，希望大家能少走一点弯路。  

## 一. 基本流程

1. **初始化**：
	- 选定目标区域：选定你要跟踪的目标，可以用鼠标在画面中选中。选定之后计算目标区域的颜色直方图作为目标的特征，颜色直方图根据自己的需要可以使用RGB或者HSV颜色空间。
	- 撒点：选定目标之后，正式开始跟踪，初始化时将粒子撒在选定区域中心点的周围。
	- 初始化每一个粒子的相似度为1/n（共有n个粒子）。
2. **传播**：为每一个点添加服从某种分布的噪声，使之扩散开来，目标搜索的范围主要由粒子散布的噪声分布模型决定，我采用服从高斯的噪声。
3. **观测**：计算每一个粒子所在区域的颜色直方图，并计算与目标区域颜色直方图的相似度，相似度使用巴氏距离，具体的计算方法见下方。
4. **估计预测结果**：预测的结果可以直接对所有点的位置求加权平均得到。
5. **更新目标模型**：将上一帧预测的结果对目标模型进行更新，使用一个更新权重，对新的模型和旧的模型进行综合。
之后就是对2，3，4，5不断重复的过程。

## 二. 目标模型

目标模型可以使用被跟踪区域的颜色直方图，分别对RGB的值进行统计，如果进行完全统计的话需要255\*255\*255大小的直方图，计算量过大，因此我们可以将0到255这2^8个数规约到0到7这8个数，以减小计算量。这样我们就只需要8*8*8的空间来保存目标模型，计算量也大大减小了。
 
## 三. 相似度

观测区域目标模型的相似度就是两个颜色直方图的相似度。在这里采用巴氏距离作为两个颜色直方图的相似度。

## 四. 高斯噪声的产生方法

产生高斯噪声实际上就是产生高斯随机数，常见的方法有三种，即12求和法、Box-Muller法和极坐标法，下面是Box-Muller方法的代码：  

[Gauss随机变量产生方法的比较研究](http://www.cnki.com.cn/Article/CJFDTOTAL-JCGC201012026.htm)  

下面的论文中是各种方法的比较：

[Box-Muller法产生随机数](http://c-faq-chn.sourceforge.net/ccfaq/node239.html)  


## 五. 重采样原理

假设共有N个粒子，每个粒子权重的数组是weight[N]  
cumulateWeight[N]数组用于存放weight数组前i项的和，即


> cumulateWeight[i] = weight[0] + weight[1] + ...+ weight[i-1];


之后产生一个随机数num，在cumulateWeight数组中寻找一个最小的j，使得
cumulateWeight[j] <=num  
这个j在weight[N]中对应的权重就是我们要找的。
为什么这种方法可以筛选出权重较大的数呢？如果weight[i]非常大，那么cumulateWeight[i]和cumulateWeight[i+1]之间的间隔也会非常大，那么随机数就有很大可能落在cumulateWeight[i]和cumulateWeight[i+1]之间，从而选出cumulateWeight[i]，其对应的权重就是weight[i];

